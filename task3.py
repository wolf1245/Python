#!/usr/bin/env python
# coding: utf-8

# # Функции
# ### Домашнее задание

# #### 1.
# Почему возникла ошибка? Объясните и исправьте.
def factorial(n):
    f = 1
    for i in range(2, n + 1):
        f = f * i
    return f


print(factorial(3))

# **Объяснение:**
# #### 2.
# Почему переменная S после запуска функции сохранила значение ноль?
# Они находятся в разной области видимости
S = 0


def my_sum(n, m):
    S = n + m
    return S


print(my_sum(3, 4))
print(S)


# **Объяснение:**
# #### 3.
# Почему возникла ошибка? Объясните и исправьте, чтобы функция могла работать с данными на входе в примере с `res`.
# На первом месте стоит символ * обязательно перечисление аргументов
# в функцию при передаче в строго именованном порядке
def mult(*, q, w, e, r, t, y):
    return q + w + e + r + t + y


res = mult(q=1, w=2, e=3, r=4, t=5, y=6)


# **Объяснение:**
# #### 4.
# Почему возникла ошибка? Объясните и исправьте, чтобы функция могла работать с данными на входе в примере.
# На третьем месте стоит символ * обязательно перечисление аргументов
# в функцию при передаче в строго именованном порядке
def power(a, s, *, d):
    result = a ** s ** d
    print(result)


power(a=4, s=5, d=6)


# #### 5.
# Почему возникла ошибка? Объясните и исправьте, чтобы функция могла работать с данными на входе в примере.
# Ожидались аргументы в виде списка
def mult2(*args):
    result = 1
    for i in args:
        result += i
    return result


print(mult2([1, 2, 3, 4, 5, 6, 7]))


# #### 6.
# Почему возникла ошибка? Объясните и исправьте.
# Аргументы шли не по порядку
def some_function(a, b, *args, **kwargs):
    pass


# **Объяснение:**
# #### 7.
# Почему не был создан новый список при повторном запуске функции? Объясните и исправьте.
# В аргументе было присвоено по умолчанию пустой список [], лучше создать в самой функции
def to_buy(*new_items):
    shopping_list = []
    for i in new_items:
        shopping_list.append(i)
    return shopping_list


monday = to_buy('яблоки', 'молоко', 'хлеб')
print(monday)

tuesday = to_buy('груши', 'йогурт', 'мясо')
print(tuesday)


# **Объяснение:**
# #### 8.
# Измените данную функцию так, чтобы она распечатывала названия продуктов из словаря в примере.
#
def print_all(*kwargs):
    for i in kwargs:
        print(i)


print_all(*{'1': 'яблоки', '2': 'молоко', '3': 'хлеб', '4': 'груши', '5': 'йогурт', '6': 'мясо'})

# #### 9.
# Программисты договорились, что переменные такого рода являются.. *(вопрос из лекции)*

TOKEN = ...


# **Ответ:**
# Константой

# #### 10.
# Напишите функцию, которая с помощью рекурсии считает сумму последовательности с шагом m.
# В качестве аргументов подаются целые положительные числа n (последний элемент последовательности)
# и m (шаг последовательности). Считается, что все члены последовательности являются целыми положительными числами.
# 
# Пример:
# 
# ```
# sum_of_seq(5, 1)
# 15
#  
# sum_of_seq(5, 9)
# 5
# 
# sum_of_seq(8, 2)
# 20
def sum_of_seq(n, m):
    """
    Функция для рекурсивного подсчета суммы последовательности с шагом m.
    """
    # Базовый случай: если n меньше или равно нулю, возвращаем 0
    if n <= 0:
        return 0
    # Рекурсивный случай: суммируем n и результат вызова функции для n - m
    return n + sum_of_seq(n - m, m)


# Примеры использования функции
print(sum_of_seq(5, 1))


# #### 11.
# Напишите функцию, которая возводит число в положительную степень с помощью рекурсии.
# В качестве аргументов подаются целые положительные числа n (число) и m (степень).

def power_recursive(n, m):
    """
    Функция для возведения числа n в степень m с помощью рекурсии.
    """
    # Базовый случай: если степень равна 0, возвращаем 1
    if m == 0:
        return 1
    # Рекурсивный случай: умножаем n на результат возведения n в степень m-1
    return n * power_recursive(n, m - 1)


# Примеры использования функции
print(power_recursive(2, 3))


# #### 12.
# Напишите функцию, которая возводит число в отрицательную степень число с помощью рекурсии.
# В качестве аргументов подаются целое положительное число n (число) и целое отрицательное число m (степень).
def power_recursive(n, m):
    """
    Функция для возведения числа n в отрицательную степень m с помощью рекурсии.
    """
    # Базовый случай: если степень равна 0, возвращаем 1
    if m == 0:
        return 1
    # Рекурсивный случай: умножаем на результат вызова функции для положительной степени и берем обратное значение
    return 1 / (n * power_recursive(n, -m - 1))


# Примеры использования функции
print(power_recursive(2, -3))


# #### 13.
# Напишите функцию, которая находит число Фиббоначи по его номеру.
# В качестве аргумента подается целое положительное число n (число).
def fibonacci(n):
    """
    Функция для нахождения числа Фибоначчи по его номеру с помощью рекурсии.
    """
    # Базовый случай: если n равно 1 или 2, возвращаем 1
    if n == 1 or n == 2:
        return 1
    # Рекурсивный случай: возвращаем сумму двух предыдущих чисел Фибоначчи
    return fibonacci(n - 1) + fibonacci(n - 2)


# Примеры использования функции
print(fibonacci(1))
